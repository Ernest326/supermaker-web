import { I as Id, T as Timestamp, E as Empty, H as HopShDomain, a as InternalHopDomain, M as Method, b as ExtractRouteParams } from './types-d4dfa8cd.js';
export { A as AnyId, E as Empty, b as ExtractRouteParams, H as HopShDomain, d as ID_PREFIXES, I as Id, e as IdPrefixes, a as InternalHopDomain, M as Method, c as Tag, T as Timestamp, V as Values, h as asId, j as assertId, g as getIdPrefix, i as id, f as validateId, v as validateIdPrefix } from './types-d4dfa8cd.js';

/**
 * A user objct
 */
interface User {
    /**
     * The ID of the user
     */
    id: Id<'user'>;
    /**
     * The name of the user. Think of this as a display name
     */
    name: string;
    /**
     * A unqiue username for the user
     */
    username: string;
    /**
     * The email of the user
     */
    email: string;
}
interface PAT {
    /**
     * The ID of the pat
     */
    id: Id<'pat'>;
    /**
     * The name of the pat
     */
    name: string | null;
    /**
     * The pat token
     *
     * @warning This value will be partially censored if it
     */
    pat: string;
    /**
     * The date the pat was created
     */
    created_at: Timestamp;
}
declare type UserEndpoints = Endpoint<'GET', '/v1/users/@me', {
    projects: Project[];
    user: User;
    project_member_role_map: Record<Id<'project'>, MemberRole>;
    leap_token: string | null;
}> | Endpoint<'POST', '/v1/users/@me/pats', {
    pat: PAT;
}, {
    name: string;
}> | Endpoint<'GET', '/v1/users/@me/pats', {
    pats: PAT[];
}> | Endpoint<'DELETE', '/v1/users/@me/pats/:pat_id', Empty>;

type users_User = User;
type users_PAT = PAT;
type users_UserEndpoints = UserEndpoints;
declare namespace users {
  export {
    users_User as User,
    users_PAT as PAT,
    users_UserEndpoints as UserEndpoints,
  };
}

declare type Member = Omit<User, 'email' | 'id'> & {
    /**
     * The ID of the project member
     */
    id: Id<'pm'>;
    /**
     * The role that this member has in a project
     */
    role: MemberRole;
    /**
     * The date that this member joined the project
     */
    joined_at: Timestamp;
};
declare enum ProjectTier {
    FREE = "free",
    PAID = "paid"
}
interface MemberRole {
    /**
     * The ID of the role
     */
    id: Id<'role'>;
    /**
     * The name of the role
     */
    name: string;
    /**
     * The flags for this role
     */
    flags: number;
}
/**
 * A project token for a project
 */
interface ProjectToken {
    /**
     * The Id of the project token
     */
    id: Id<'ptkid'>;
    /**
     * The key value. This will likely have half of the key obfuscated
     */
    token: Id<'ptk'>;
    /**
     * The time this project token was created
     */
    created_at: Timestamp;
    /**
     * Permissions and flags that this project token can perform
     */
    flags: number;
}
/**
 * Type of a project
 */
declare enum ProjectType {
    /**
     * A regular project is
     */
    REGULAR = "regular",
    /**
     * A personal project are created when you register an account
     */
    PERSONAL = "personal"
}
interface Project {
    /**
     * The ID of the project
     */
    id: Id<'project'>;
    /**
     * The name of the project
     */
    name: string;
    /**
     * The tier this project is
     */
    tier: ProjectTier;
    /**
     * The time this project was created at
     */
    created_at: Timestamp;
    /**
     * An icon for this project
     */
    icon: string | null;
    /**
     * The registry namespace for this project
     */
    namespace: string;
    /**
     * The type of this project. Either regular or personal
     */
    type: ProjectType;
    default_quotas: DefaultQuotas;
    quota_overrides: QuotaOverrides;
    quota_usage: QuotaUsage;
}
interface DefaultQuotas {
    vcpu: number;
    ram: number;
}
interface QuotaOverrides {
}
interface QuotaUsage {
    vcpu: number;
    ram: number;
}
interface Secret {
    /**
     * The ID of the secret
     */
    id: Id<'secret'>;
    /**
     * The name of the secret
     */
    name: string;
    /**
     * A digest hash of the secret
     */
    digest: string;
    /**
     * The time this secret was created at
     */
    created_at: Timestamp;
}
declare type ProjectsEndpoints = Endpoint<'DELETE', '/v1/projects/:project_id/tokens/:project_token_id', Empty> | Endpoint<'DELETE', '/v1/projects/@this/tokens/:project_token_id', Empty> | Endpoint<'GET', '/v1/projects/:project_id/members/@me', {
    project_member: Member;
}> | Endpoint<'GET', '/v1/projects/:project_id/tokens', {
    project_tokens: ProjectToken[];
}> | Endpoint<'GET', '/v1/projects/@this/tokens', {
    project_tokens: ProjectToken[];
}> | Endpoint<'GET', '/v1/projects/:project_id/members', {
    members: Member[];
}> | Endpoint<'GET', '/v1/projects/@this/members', {
    members: Member[];
}> | Endpoint<'POST', '/v1/projects/:project_id/tokens', {
    project_token: ProjectToken & {
        project: Project;
    };
}, {
    flags: number;
}> | Endpoint<'POST', '/v1/projects/@this/tokens', {
    project_token: ProjectToken & {
        project: Project;
    };
}, {
    flags: number;
}> | Endpoint<'PUT', '/v1/projects/:project_id/secrets/:name', {
    secret: Secret;
}, string> | Endpoint<'PUT', '/v1/projects/@this/secrets/:name', {
    secret: Secret;
}, string> | Endpoint<'GET', '/v1/projects/:project_id/secrets', {
    secrets: Secret[];
}> | Endpoint<'GET', '/v1/projects/@this/secrets', {
    secrets: Secret[];
}> | Endpoint<'DELETE', '/v1/projects/:project_id/secrets/:secret_id', Empty> | Endpoint<'DELETE', '/v1/projects/@this/secrets/:secret_id', Empty>;

type projects_Member = Member;
type projects_ProjectTier = ProjectTier;
declare const projects_ProjectTier: typeof ProjectTier;
type projects_MemberRole = MemberRole;
type projects_ProjectToken = ProjectToken;
type projects_ProjectType = ProjectType;
declare const projects_ProjectType: typeof ProjectType;
type projects_Project = Project;
type projects_DefaultQuotas = DefaultQuotas;
type projects_QuotaOverrides = QuotaOverrides;
type projects_QuotaUsage = QuotaUsage;
type projects_Secret = Secret;
type projects_ProjectsEndpoints = ProjectsEndpoints;
declare namespace projects {
  export {
    projects_Member as Member,
    projects_ProjectTier as ProjectTier,
    projects_MemberRole as MemberRole,
    projects_ProjectToken as ProjectToken,
    projects_ProjectType as ProjectType,
    projects_Project as Project,
    projects_DefaultQuotas as DefaultQuotas,
    projects_QuotaOverrides as QuotaOverrides,
    projects_QuotaUsage as QuotaUsage,
    projects_Secret as Secret,
    projects_ProjectsEndpoints as ProjectsEndpoints,
  };
}

declare enum ChannelType {
    PRIVATE = "private",
    PUBLIC = "public",
    UNPROTECTED = "unprotected"
}
declare type State = Record<string, unknown>;
interface Channel {
    /**
     * The ID of the channel
     */
    id: string;
    /**
     * The project it is associated with
     */
    project: Project;
    /**
     * State metadata
     */
    state: State;
    /**
     * Capabilities of the channel
     */
    capabilities: number;
    /**
     * When this channel was created
     */
    created_at: Timestamp;
    /**
     * The type of this channel
     */
    type: ChannelType;
}
interface ChannelToken {
    /**
     * The ID for the token
     */
    id: Id<'leap_token'>;
    /**
     * State for this token
     */
    state: State;
    /**
     * The project this channel token is associated with
     */
    project_id: Id<'project'>;
}
declare type ChannelEndpoints = Endpoint<'POST', '/v1/channels', {
    channel: Channel;
}, {
    type: ChannelType;
    state: Record<string, any> | null;
}> | Endpoint<'PUT', '/v1/channels/:channel_id', {
    channel: Channel;
}, {
    type: ChannelType;
    state: Record<string, any> | null;
}> | Endpoint<'POST', '/v1/channels/tokens', {
    token: ChannelToken;
}, {
    state: State;
}> | Endpoint<'DELETE', '/v1/channels/:channel_id', Empty> | Endpoint<'GET', '/v1/channels/:channel_id', {
    channel: Channel;
}> | Endpoint<'GET', '/v1/channels/:channel_id/tokens', {
    tokens: ChannelToken[];
}> | Endpoint<'POST', '/v1/channels/tokens/:token/messages', Empty, {
    e: string;
    d: unknown;
}> | Endpoint<'PUT', '/v1/channels/:channel_id/subscribers/:token', Empty> | Endpoint<'PATCH', '/v1/channels/:channel_id/state', Empty, State> | Endpoint<'PUT', '/v1/channels/:channel_id/state', Empty, State> | Endpoint<'GET', '/v1/channels/:channel_id/state', {
    state: State;
}> | Endpoint<'POST', '/v1/channels/:channel_id/messages', Empty, {
    e: string;
    d: unknown;
}> | Endpoint<'GET', '/v1/channels', {
    channels: Channel[];
}>;

type channels_ChannelType = ChannelType;
declare const channels_ChannelType: typeof ChannelType;
type channels_State = State;
type channels_Channel = Channel;
type channels_ChannelToken = ChannelToken;
type channels_ChannelEndpoints = ChannelEndpoints;
declare namespace channels {
  export {
    channels_ChannelType as ChannelType,
    channels_State as State,
    channels_Channel as Channel,
    channels_ChannelToken as ChannelToken,
    channels_ChannelEndpoints as ChannelEndpoints,
  };
}

declare type RegistryEndpoints = Endpoint<'DELETE', '/v1/registry/images/:image', Empty> | Endpoint<'GET', '/v1/registry/images', {
    images: string[];
}> | Endpoint<'GET', '/v1/registry/images/:image/manifests', {
    manifests: {
        digest: {
            digest: string;
            size: number;
            uploaded: string;
        };
        tag: string | null;
    }[];
}>;

type registry_RegistryEndpoints = RegistryEndpoints;
declare namespace registry {
  export {
    registry_RegistryEndpoints as RegistryEndpoints,
  };
}

/**
 * The default base URL for Hop's API.
 */
declare const DEFAULT_BASE_URL = "https://api.hop.io";
/**
 * If we are in the browser.
 */
declare const IS_BROWSER: boolean;

declare const units: readonly ["gb", "mb", "kb", "b"];
declare type ByteString = `${number}${typeof units[number]}`;
declare function isValidByteString(value: string): value is ByteString;
/**
 * Parses a byte size string into bytes
 * @param size The size of anything in gigabytes, megabytes, kilobytes or bytes
 */
declare function parseSize(size: string): number;

declare enum Regions {
    US_EAST_1 = "us-east-1"
}
/**
 * Runtime types are used to describe the type of a deployment or container
 */
declare enum RuntimeType {
    /**
     * Ephemeral deployments/containers are sort of fire and forget. Containers won't restart if they exit but they can still be terminated programatically.
     */
    EPHEMERAL = "ephemeral",
    /**
     * Persistent deployments/containers will restart if they exit. They can also be started and stopped programmatically.
     */
    PERSISTENT = "persistent"
}
/**
 * Container state is relatively self-explanatory. It describes what the container is currently doing.
 */
declare enum ContainerState {
    /**
     * The container is pending creation
     */
    PENDING = "pending",
    /**
     * The container is running
     */
    RUNNING = "running",
    /**
     * The container is stopped
     */
    STOPPED = "stopped",
    /**
     * The container's entrypoint failed (e.g. exited with a non-zero exit code)
     */
    FAILED = "failed",
    /**
     * The container is being deleted
     */
    TERMINATING = "terminating",
    /**
     * The container exited (e.g. with a zero exit code)
     */
    EXITED = "exited"
}
/**
 * Types for supported GPU
 */
declare enum VgpuType {
    A400 = "a400"
}
interface Container {
    /**
     * The ID of the container
     */
    id: Id<'container'>;
    /**
     * The time this container was created
     */
    created_at: Timestamp;
    /**
     * The region this container runs in
     */
    region: Regions;
    /**
     * Information about uptime/downtime for this container
     */
    uptime: {
        /**
         * The last time this container was started at
         */
        last_start: Timestamp;
    };
    /**
     * The type of this container
     */
    type: RuntimeType;
    /**
     * The internal IP of the container
     */
    internal_ip: string;
    /**
     * The ID of the deployment this container is associated with
     */
    deployment_id: Id<'deployment'>;
    /**
     * The state this container is in
     */
    state: ContainerState;
}
interface Deployment {
    /**
     * The ID of the deployment
     */
    id: Id<'deployment'>;
    /**
     * The name of the deployment
     */
    name: string;
    /**
     * The amount of containers this deployment is currently running
     */
    container_count: number;
    /**
     * The time this deployment was created at
     */
    created_at: Timestamp;
    /**
     * The config for this deployment
     */
    config: DeploymentConfig;
}
declare type DeploymentConfig = {
    /**
     * The name of the deployment
     */
    name: string;
    /**
     * The strategy for scaling multiple containers.
     *
     * Manual = add containers yourself
     *
     * @warning This property is not yet fully complete
     */
    container_strategy: 'manual';
    /**
     * The type of this deployment
     */
    type: RuntimeType;
    /**
     * The version of this config
     */
    version: '2022-05-17';
    /**
     * The docker image config for this deployment
     */
    image: Image;
    /**
     * Environment variables for this deployment
     */
    env: Record<string, string>;
    /**
     * Resources allocated to this deployment
     */
    resources: Resources;
};
/**
 * Docker image config
 */
interface Image {
    /**
     * The name of the docker image
     */
    name: string | null;
    /**
     * Authorization required for the registry to access this image
     * This is not required if you use Hop's own registry.
     */
    auth: Auth | null;
    /**
     * GitHub repo information (if applicable)
     */
    gh_repo: ImageGHRepo | null;
}
/**
 * Docker image registry authorization
 */
interface Auth {
    username: string;
    password: string;
}
/**
 * GitHub repo type sent from API (NOT USED IN IMAGES)
 */
interface GHRepo {
    id: number;
    full_name: string;
    private: boolean;
    default_branch: string;
    account_name: string;
}
/**
 * GitHub repo partial used for images
 */
interface ImageGHRepo {
    repo_id: number;
    full_name: string;
    branch: string;
}
/**
 * Resources allocated to a deployment
 */
interface Resources {
    /**
     * Amount of vCPU to allocate
     */
    vcpu: number;
    /**
     * Amount of memory to allocate in a readible format
     * You can use the `parseSize` function to convert this to bytes.
     */
    ram: ByteString;
    /**
     * vGPUs to allocate
     */
    vgpu: Vgpu[];
}
/**
 * Virtual GPU config
 */
interface Vgpu {
    /**
     * The type of vGPU to allocate
     */
    type: VgpuType;
    /**
     * The amount of vGPUs to allocate
     */
    count: number;
}
/**
 * Logs from a container
 */
interface ContainerLog {
    /**
     * The timestamp of the log
     */
    timestamp: Timestamp;
    /**
     * The log message
     */
    message: string;
    /**
     * The ID of the document in elasticsearch. You probably won't have to use this, but
     * it might be useful for React keys, for example, as they are unique.
     */
    nonce: string;
    /**
     * The level of the log. stdout becomes `info`
     */
    level: 'info' | 'stderr';
}
/**
 * Types of gateways supported by Hop
 */
declare enum GatewayType {
    /**
     * The gateway can only be accessed inside of a project's network
     */
    INTERNAL = "internal",
    /**
     * The gateway can be accessed from the internet
     */
    EXTERNAL = "external"
}
/**
 * Gateways are used to connect services to the internet or a private network
 */
interface Gateway {
    /**
     * The ID of the gateway
     */
    id: Id<'gateway'>;
    /**
     * The type of the gateway
     */
    type: GatewayType;
    /**
     * The name of the gateway
     */
    name: string;
    /**
     * The protocol for this gateway (Only for external)
     *
     * @warning Currently, hop only supports HTTP. This will eventually change to an enum
     */
    protocol: 'http' | null;
    /**
     * The deployment this gateway is associated with
     */
    deployment_id: Id<'deployment'>;
    /**
     * The date this gateway was created
     */
    created_at: Timestamp;
    /**
     * Domain automatically assigned by Hop
     */
    hopsh_domain: HopShDomain | null;
    /**
     * Internal domain assigned by user upon gateway creation
     */
    internal_domain: InternalHopDomain | null;
    /**
     * Port the Gateway targets (Only for external gateways)
     */
    target_port: number | null;
    /**
     * Domains associated with this gateway
     */
    domains: Domain[];
}
declare enum DomainState {
    PENDING = "pending",
    VALID_CNAME = "valid_cname",
    SSL_ACTIVE = "ssl_active"
}
interface Domain {
    /**
     * The ID of the domain
     */
    id: Id<'domain'>;
    /**
     * The domain name
     */
    domain: string;
    /**
     * The domain state
     */
    state: DomainState;
    /**
     * The date this domain was created
     */
    created_at: Timestamp;
}
declare type IgniteEndpoints = Endpoint<'GET', '/v1/ignite/deployments', {
    deployments: Deployment[];
}> | Endpoint<'GET', '/v1/ignite/deployments/:deployment_id/containers', {
    containers: Container[];
}> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/containers', {
    container: Container;
}> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/containers/:container_id', never, {
    /**
     * The ID of the deployment
     */
    deployment_id: Id<'deployment'>;
    /**
     * The ID of the container
     */
    container_id: Id<'container'>;
}> | Endpoint<'POST', '/v1/ignite/deployments', {
    deployment: Deployment;
}, DeploymentConfig> | Endpoint<'DELETE', '/v1/ignite/deployments/:deployment_id', Empty> | Endpoint<'DELETE', '/v1/ignite/containers/:container_id', Empty> | Endpoint<'GET', '/v1/ignite/containers/:container_id/logs', {
    logs: ContainerLog[];
}> | Endpoint<'GET', '/v1/ignite/deployments/search', {
    deployment: Deployment;
}> | Endpoint<'GET', '/v1/ignite/deployments/:deployment_id', {
    deployment: Deployment;
}> | Endpoint<'PUT', '/v1/ignite/containers/:container_id/state', Empty, {
    /**
     * The state to update the container to
     */
    preferred_state: ContainerState.STOPPED | ContainerState.RUNNING;
}> | Endpoint<'POST', '/v1/ignite/gateways/:gateway_id/domains', Empty, {
    domain: string;
}> | Endpoint<'GET', '/v1/ignite/gateways/:gateway_id', {
    gateway: Gateway;
}> | Endpoint<'GET', '/v1/ignite/deployments/:deployment_id/gateways', {
    gateways: Gateway[];
}> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/gateways', {
    gateway: Gateway;
}, {
    type: GatewayType;
    listening_port: number;
    protocol: Gateway['protocol'];
}>;

type ignite_Regions = Regions;
declare const ignite_Regions: typeof Regions;
type ignite_RuntimeType = RuntimeType;
declare const ignite_RuntimeType: typeof RuntimeType;
type ignite_ContainerState = ContainerState;
declare const ignite_ContainerState: typeof ContainerState;
type ignite_VgpuType = VgpuType;
declare const ignite_VgpuType: typeof VgpuType;
type ignite_Container = Container;
type ignite_Deployment = Deployment;
type ignite_DeploymentConfig = DeploymentConfig;
type ignite_Image = Image;
type ignite_Auth = Auth;
type ignite_GHRepo = GHRepo;
type ignite_ImageGHRepo = ImageGHRepo;
type ignite_Resources = Resources;
type ignite_Vgpu = Vgpu;
type ignite_ContainerLog = ContainerLog;
type ignite_GatewayType = GatewayType;
declare const ignite_GatewayType: typeof GatewayType;
type ignite_Gateway = Gateway;
type ignite_DomainState = DomainState;
declare const ignite_DomainState: typeof DomainState;
type ignite_Domain = Domain;
type ignite_IgniteEndpoints = IgniteEndpoints;
declare namespace ignite {
  export {
    ignite_Regions as Regions,
    ignite_RuntimeType as RuntimeType,
    ignite_ContainerState as ContainerState,
    ignite_VgpuType as VgpuType,
    ignite_Container as Container,
    ignite_Deployment as Deployment,
    ignite_DeploymentConfig as DeploymentConfig,
    ignite_Image as Image,
    ignite_Auth as Auth,
    ignite_GHRepo as GHRepo,
    ignite_ImageGHRepo as ImageGHRepo,
    ignite_Resources as Resources,
    ignite_Vgpu as Vgpu,
    ignite_ContainerLog as ContainerLog,
    ignite_GatewayType as GatewayType,
    ignite_Gateway as Gateway,
    ignite_DomainState as DomainState,
    ignite_Domain as Domain,
    ignite_IgniteEndpoints as IgniteEndpoints,
  };
}

declare namespace api {
  export {
    channels as Channels,
    registry as Registry,
    ignite as Ignite,
    pipe as Pipe,
    projects as Projects,
    users as Users,
  };
}

declare type SuccessfulAPIResponse<T> = {
    success: true;
    data: T;
};
declare type ErroredAPIResponse = {
    success: false;
    error: {
        code: string;
        message: string;
    };
};
declare type APIResponse<T> = SuccessfulAPIResponse<T> | ErroredAPIResponse;
declare type Endpoint<M extends Method, Path extends string, Res, Body = undefined> = {
    method: M;
    path: Path;
    res: Res;
    body: Body;
};
declare type Endpoints = IgniteEndpoints | RegistryEndpoints | UserEndpoints | ProjectsEndpoints | PipeEndpoints | ChannelEndpoints;

declare type DeliveryProtocol = 'webrtc' | 'hls';
interface Room {
    /**
     * The ID of this stream
     */
    id: Id<'pipe_room'>;
    /**
     * The name of this room
     */
    name: string;
    /**
     * The unix timestamp of when this stream was created
     */
    created_at: Timestamp;
    /**
     * Protocol you can stream with
     */
    ingest_protocol: 'rtmp';
    /**
     * Protocols that are supported by this room to the client
     */
    delivery_protocols: DeliveryProtocol[];
    /**
     * A join token to subscribe into this room
     */
    join_token: string;
    /**
     * The region that the stream url is located in
     */
    ingest_region: Regions;
    /**
     * The URL that you can stream to
     */
    ingest_endpoint: string;
    /**
     * The state of the stream currently
     */
    state: 'live' | 'offline';
}
declare type PipeEndpoints = Endpoint<'GET', '/v1/pipe/rooms', {
    rooms: Room[];
}> | Endpoint<'POST', '/v1/pipe/rooms', {
    room: Room;
}, {
    /**
     * The name of the stream
     */
    name: string;
    ingest_protocol: 'rtmp' | 'rtp';
    delivery_protocols: DeliveryProtocol[];
    region: Regions;
    ephemeral: boolean;
    llhls_config?: {
        wcl_delay: number;
        artificial_delay: number;
        max_playout_bitrate_preset: string;
    };
}> | Endpoint<'DELETE', '/v1/pipe/rooms/:room_id', Empty>;

type pipe_DeliveryProtocol = DeliveryProtocol;
type pipe_Room = Room;
type pipe_PipeEndpoints = PipeEndpoints;
declare namespace pipe {
  export {
    pipe_DeliveryProtocol as DeliveryProtocol,
    pipe_Room as Room,
    pipe_PipeEndpoints as PipeEndpoints,
  };
}

declare type APIAuthentication = Id<'ptk'> | Id<'bearer'> | Id<'pat'>;
declare type APIAuthenticationType = APIAuthentication extends Id<infer T> ? T : never;
declare function validateAPIAuthentication(auth: string): auth is APIAuthenticationType;
interface APIClientOptions {
    readonly baseUrl: string;
    readonly authentication: APIAuthentication;
}
declare class HopAPIError extends Error {
    readonly request: Request;
    readonly response: Response;
    readonly data: ErroredAPIResponse;
    readonly status: number;
    constructor(request: Request, response: Response, data: ErroredAPIResponse);
}
declare type Query<Path extends string> = ExtractRouteParams<Path> & Record<string, string | number | undefined>;
declare class APIClient {
    static getAuthType(auth: APIAuthentication): "ptk" | "pat" | "bearer";
    private readonly options;
    readonly authType: "ptk" | "pat" | "bearer";
    readonly url: <Path extends string>(path: Path, query: Query<Path>) => string;
    constructor(options: APIClientOptions);
    get<Path extends Extract<Endpoints, {
        method: 'GET';
    }>['path']>(path: Path, query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"GET", "/v1/users/@me", {
        projects: Project[];
        user: User;
        project_member_role_map: Record<`project_${string}`, MemberRole>;
        leap_token: string | null;
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/users/@me/pats", {
        pats: PAT[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/members/@me", {
        project_member: Member;
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/tokens", {
        project_tokens: ProjectToken[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/@this/tokens", {
        project_tokens: ProjectToken[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/members", {
        members: Member[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/@this/members", {
        members: Member[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/secrets", {
        secrets: Secret[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/@this/secrets", {
        secrets: Secret[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/:channel_id", {
        channel: Channel;
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/:channel_id/tokens", {
        tokens: ChannelToken[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/:channel_id/state", {
        state: State;
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels", {
        channels: Channel[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/registry/images", {
        images: string[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/registry/images/:image/manifests", {
        manifests: {
            digest: {
                digest: string;
                size: number;
                uploaded: string;
            };
            tag: string | null;
        }[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments", {
        deployments: Deployment[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/:deployment_id/containers", {
        containers: Container[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/containers/:container_id/logs", {
        logs: ContainerLog[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/search", {
        deployment: Deployment;
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/:deployment_id", {
        deployment: Deployment;
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/gateways/:gateway_id", {
        gateway: Gateway;
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/:deployment_id/gateways", {
        gateways: Gateway[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/pipe/rooms", {
        rooms: Room[];
    }, undefined>, {
        path: Path;
        method: 'GET';
    }>)["res"]>;
    post<Path extends Extract<Endpoints, {
        method: 'POST';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'POST';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"POST", "/v1/users/@me/pats", {
        pat: PAT;
    }, {
        name: string;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/projects/:project_id/tokens", {
        project_token: ProjectToken & {
            project: Project;
        };
    }, {
        flags: number;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/projects/@this/tokens", {
        project_token: ProjectToken & {
            project: Project;
        };
    }, {
        flags: number;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels", {
        channel: Channel;
    }, {
        type: ChannelType;
        state: Record<string, any> | null;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels/tokens", {
        token: ChannelToken;
    }, {
        state: State;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels/tokens/:token/messages", void, {
        e: string;
        d: unknown;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels/:channel_id/messages", void, {
        e: string;
        d: unknown;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/containers", {
        container: Container;
    }, undefined>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/containers/:container_id", never, {
        deployment_id: `deployment_${string}`;
        container_id: `container_${string}`;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments", {
        deployment: Deployment;
    }, DeploymentConfig>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/gateways/:gateway_id/domains", void, {
        domain: string;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/gateways", {
        gateway: Gateway;
    }, {
        type: GatewayType;
        listening_port: number;
        protocol: "http" | null;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/pipe/rooms", {
        room: Room;
    }, {
        name: string;
        ingest_protocol: "rtmp" | "rtp";
        delivery_protocols: DeliveryProtocol[];
        region: Regions;
        ephemeral: boolean;
        llhls_config?: {
            wcl_delay: number;
            artificial_delay: number;
            max_playout_bitrate_preset: string;
        } | undefined;
    }>, {
        path: Path;
        method: 'POST';
    }>)["res"]>;
    put<Path extends Extract<Endpoints, {
        method: 'PUT';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'PUT';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"PUT", "/v1/projects/:project_id/secrets/:name", {
        secret: Secret;
    }, string>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/projects/@this/secrets/:name", {
        secret: Secret;
    }, string>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/channels/:channel_id", {
        channel: Channel;
    }, {
        type: ChannelType;
        state: Record<string, any> | null;
    }>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/channels/:channel_id/subscribers/:token", void, undefined>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/channels/:channel_id/state", void, State>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/ignite/containers/:container_id/state", void, {
        preferred_state: ContainerState.RUNNING | ContainerState.STOPPED;
    }>, {
        path: Path;
        method: 'PUT';
    }>)["res"]>;
    patch<Path extends Extract<Endpoints, {
        method: 'PATCH';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'PATCH';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<Extract<Endpoint<"PATCH", "/v1/channels/:channel_id/state", void, State>, {
        path: Path;
        method: 'PATCH';
    }>["res"]>;
    delete<Path extends Extract<Endpoints, {
        method: 'DELETE';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'DELETE';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"DELETE", "/v1/users/@me/pats/:pat_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/:project_id/tokens/:project_token_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/@this/tokens/:project_token_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/:project_id/secrets/:secret_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/@this/secrets/:secret_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/channels/:channel_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/registry/images/:image", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/ignite/deployments/:deployment_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/ignite/containers/:container_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/pipe/rooms/:room_id", void, undefined>, {
        path: Path;
        method: 'DELETE';
    }>)["res"]>;
    raw<T>(request: Request): Promise<T>;
    private parseResponse;
    private request;
}

/**
 * New state to set to a channel, or a callback function that will produce the new state
 */
declare type SetStateAction<T extends State> = T | ((oldState: T) => T | Promise<T>);

declare type PartialAPIOptions = Partial<Omit<APIClientOptions, 'authentication'>> & Pick<APIClientOptions, 'authentication'>;
/**
 * Constructs a new instance of Hop and all of its SDKs.
 *
 * @example
 * ```ts
 * const hop = new Hop(bearerTokenOrPATOrProjectToken);
 * await hop.ignite.containers.create(deploymentId);
 * ```
 */
declare class Hop {
    readonly client: APIClient;
    readonly ignite: {
        gateways: {
            addDomain(gatewayId: `gateway_${string}`, domain: string): Promise<void>;
            get(gatewayId: `gateway_${string}`): Promise<Gateway>;
        };
        deployments: {
            create: {
                (configOrProject: `project_${string}`, bearerOrPatConfig: DeploymentConfig): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(type: GatewayType, protocol: "http" | null, port: number): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                    }>;
                }>;
                (configOrProject: DeploymentConfig): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(type: GatewayType, protocol: "http" | null, port: number): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                    }>;
                }>;
            };
            get: {
                (projectId: `project_${string}`, name: string): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(type: GatewayType, protocol: "http" | null, port: number): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                    }>;
                }>;
                (id: `deployment_${string}`): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(type: GatewayType, protocol: "http" | null, port: number): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                    }>;
                }>;
            };
            getContainers(deployment: `deployment_${string}`): Promise<Container[]>;
            getAll(projectId?: `project_${string}` | undefined): Promise<(Deployment & {
                getContainers(): Promise<Container[]>;
                delete(): Promise<void>;
                createContainer(): Promise<Container>;
                createGateway(type: GatewayType, protocol: "http" | null, port: number): Promise<Gateway & {
                    addDomain(domain: string): Promise<void>;
                }>;
            })[]>;
            delete(deployment: `deployment_${string}`): Promise<void>;
            gateways: {
                getAll(deploymentId: `deployment_${string}`): Promise<(Gateway & {
                    addDomain(domain: string): Promise<void>;
                })[]>;
                create(deployment: `deployment_${string}` | Deployment, type: GatewayType, protocol: "http" | null, listeningPort: number): Promise<Gateway & {
                    addDomain(domain: string): Promise<void>;
                }>;
            };
        };
        containers: {
            delete(container: `container_${string}`): Promise<void>;
            getLogs(container: `container_${string}`, options?: Partial<{
                sortBy: "timestamp";
                orderBy: "desc" | "asc";
                limit: number;
                offset: number;
            }>): Promise<ContainerLog[]>;
            stop(container: `container_${string}`): Promise<void>;
            start(container: `container_${string}`): Promise<void>;
            create(deployment: `deployment_${string}`): Promise<Container>;
        };
    };
    readonly users: {
        me: {
            get(): Promise<{
                projects: Project[];
                user: User;
                project_member_role_map: Record<`project_${string}`, MemberRole>;
                leap_token: string | null;
            }>;
            pats: {
                create(name: string): Promise<PAT>;
                getAll(): Promise<PAT[]>;
                delete(id: `pat_${string}`): Promise<void>;
            };
        };
    };
    readonly projects: {
        getAllMembers(projectId?: `project_${string}` | undefined): Promise<Member[]>;
        getCurrentMember(projectId: `project_${string}`): Promise<Member>;
        projectTokens: {
            delete(projectTokenId: `ptkid_${string}`, project?: `project_${string}` | undefined): Promise<void>;
            get(projectId?: `project_${string}` | undefined): Promise<ProjectToken[]>;
            create(flags: number, projectId?: `project_${string}` | undefined): Promise<ProjectToken & {
                project: Project;
            }>;
        };
        secrets: {
            getAll(projectId?: `project_${string}` | undefined): Promise<Secret[]>;
            create(name: string, value: string, projectId?: `project_${string}` | undefined): Promise<Secret>;
            delete(id: string, projectId?: `project_${string}` | undefined): Promise<void>;
        };
    };
    readonly pipe: {
        rooms: {
            getAll(project?: `project_${string}` | undefined): Promise<(Room & {
                delete(): Promise<void>;
            })[]>;
            create(name: string, options: {
                deliveryProtocols: DeliveryProtocol[];
                ephemeral?: boolean | undefined;
                ingestProtocol: "rtmp" | "rtp";
                hlsConfig?: {
                    wcl_delay: number;
                    artificial_delay: number;
                    max_playout_bitrate_preset: string;
                } | undefined;
            }): Promise<Room & {
                delete(): Promise<void>;
            }>;
            delete(room: `pipe_room_${string}`): Promise<void>;
        };
    };
    readonly registry: {
        images: {
            getAll(project?: `project_${string}` | undefined): Promise<string[]>;
            getManifest(image: string): Promise<{
                digest: {
                    digest: string;
                    size: number;
                    uploaded: string;
                };
                tag: string | null;
            }[]>;
            delete(image: string): Promise<void>;
        };
    };
    readonly channels: {
        create<T extends State>(type: ChannelType, id?: string | null | undefined, options?: {
            state?: T | undefined;
        } | null | undefined, project?: `project_${string}` | undefined): Promise<Channel & {
            setState<T_1 extends State>(state: SetStateAction<T_1>): Promise<void>;
            patchState<T_2 extends State>(state: SetStateAction<T_2>): Promise<void>;
            subscribeToken(token: `leap_token_${string}`): Promise<void>;
            subscribeTokens(tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
            publishMessage(name: string, data: unknown): Promise<void>;
        }>;
        get(id: string): Promise<Channel & {
            setState<T_1 extends State>(state: SetStateAction<T_1>): Promise<void>;
            patchState<T_2 extends State>(state: SetStateAction<T_2>): Promise<void>;
            subscribeToken(token: `leap_token_${string}`): Promise<void>;
            subscribeTokens(tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
            publishMessage(name: string, data: unknown): Promise<void>;
        }>;
        getAll(project?: `project_${string}` | undefined): Promise<(Channel & {
            setState<T_1 extends State>(state: SetStateAction<T_1>): Promise<void>;
            patchState<T_2 extends State>(state: SetStateAction<T_2>): Promise<void>;
            subscribeToken(token: `leap_token_${string}`): Promise<void>;
            subscribeTokens(tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
            publishMessage(name: string, data: unknown): Promise<void>;
        })[]>;
        subscribeToken(channel: string | Channel, token: `leap_token_${string}`): Promise<void>;
        subscribeTokens(channel: string | Channel, tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
        getAllTokens(channel: string | Channel): Promise<ChannelToken[]>;
        setState<T_3 extends State = State>(channel: string | Channel, state: SetStateAction<T_3>): Promise<void>;
        patchState<T_4 extends State>(channel: string | Channel, state: SetStateAction<T_4>): Promise<void>;
        publishMessage<T_5>(channel: string | Channel, event: string, data: T_5): Promise<void>;
        tokens: {
            create(state: State, project?: `project_${string}` | undefined): Promise<ChannelToken>;
            publishDirectMessage<T_6>(token: `leap_token_${string}`, event: string, data: T_6): Promise<void>;
        };
    };
    constructor(options: PartialAPIOptions);
    constructor(authentication: APIAuthentication, baseurl?: string);
}

declare enum PROJECT_PERMISSION {
    ADD_MEMBER = "add_member",
    REMOVE_MEMBER = "remove_member",
    GET_PROJECT_MEMBERS = "get_project_members",
    DELETE_PROJECT = "delete_project",
    DELETE_DEPLOYMENT = "delete_deployment",
    DELETE_CONTAINER = "delete_container",
    UPDATE_CONTAINER_STATE = "update_container_state",
    READ_DEPLOYMENTS = "read_deployments",
    CREATE_DEPLOYMENT = "create_deployment",
    CREATE_CONTAINER = "create_container",
    UPDATE_CONTAINER_CONFIG = "update_container_config",
    CREATE_ROOM = "create_room",
    READ_ROOM = "read_room",
    DELETE_ROOM = "delete_room",
    CREATE_ROOM_PRODUCER = "create_room_producer",
    CREATE_PROJECT_TOKEN = "create_project_token",
    DELETE_PROJECT_TOKEN = "delete_project_token",
    READ_PROJECT_TOKENS = "read_project_tokens",
    READ_CONTAINER_LOGS = "read_container_logs",
    CREATE_PROJECT_SECRET = "create_project_secret",
    READ_PROJECT_SECRETS = "read_project_secrets",
    DELETE_PROJECT_SECRET = "delete_project_secret",
    GET_REGISTRY_IMAGES = "get_registry_images",
    CREATE_CHANNEL = "create_channel",
    CREATE_CHANNEL_TOKEN = "create_channel_token",
    CREATE_LEAP_TOKEN = "create_leap_token",
    CREATE_GATEWAY = "create_gateway",
    ADD_DOMAIN = "add_domain",
    DELETE_CHANNELS = "delete_channels",
    UPDATE_CHANNEL_STATE = "update_channel_state",
    PUBLISH_CHANNEL_MESSAGES = "publish_channel_messages",
    READ_CHANNELS = "read_channels",
    READ_LEAP_TOKENS = "read_leap_tokens",
    MANAGE_CHANNEL_SUBSCRIBERS = "manage_channel_subscribers",
    UPDATE_LEAP_TOKEN = "update_leap_token",
    DELETE_DOMAIN = "delete_domain",
    DELETE_GATEWAY = "delete_gateway",
    GET_INTERNAL_DOMAIN = "get_internal_domain",
    MESSAGE_TOKEN = "message_token",
    ROLLOUT = "rollout",
    REQUEST_QUOTA_INCREASE = "request_quota_increase",
    READ_BILLING = "read_billing",
    READ_GATEWAYS = "read_gateways",
    DELETE_REGISTRY_IMAGES = "delete_registry_images"
}
declare const permissionsMap: {
    add_member: bigint;
    remove_member: bigint;
    get_project_members: bigint;
    delete_project: bigint;
    delete_deployment: bigint;
    delete_container: bigint;
    update_container_state: bigint;
    read_deployments: bigint;
    create_deployment: bigint;
    create_container: bigint;
    update_container_config: bigint;
    create_room: bigint;
    read_room: bigint;
    delete_room: bigint;
    create_room_producer: bigint;
    create_project_token: bigint;
    delete_project_token: bigint;
    read_project_tokens: bigint;
    read_container_logs: bigint;
    create_project_secret: bigint;
    read_project_secrets: bigint;
    delete_project_secret: bigint;
    get_registry_images: bigint;
    create_channel_token: bigint;
    create_gateway: bigint;
    add_domain: bigint;
    delete_channels: bigint;
    update_channel_state: bigint;
    read_channels: bigint;
    publish_channel_messages: bigint;
    manage_channel_subscribers: bigint;
    delete_domain: bigint;
    delete_gateway: bigint;
    get_internal_domain: bigint;
    create_leap_token: bigint;
    read_leap_tokens: bigint;
    update_leap_token: bigint;
    message_token: bigint;
    create_channel: bigint;
    rollout: bigint;
    request_quota_increase: bigint;
    read_billing: bigint;
    read_gateways: bigint;
    delete_registry_images: bigint;
};
declare const BROAD_PERMISSIONS_MAP: {
    MANAGE_MEMBERS: bigint;
    MANAGE_PROJECT_TOKENS: bigint;
    MANAGE_DEPLOYMENTS: bigint;
    MANAGE_PIPE: bigint;
    MANAGE_SECRETS: bigint;
    MANAGE_CHANNELS: bigint;
    MANAGE_REGISTRY: bigint;
    READ_ONLY: bigint;
    MANAGE_QUOTAS: bigint;
    MANAGE_ROLLOUTS: bigint;
    MANAGE_BILLING: bigint;
};
declare const roles: {
    viewer: bigint;
    editor: bigint;
    admin: bigint;
    owner: bigint;
};
declare const permissions: {
    add(value: bigint, flag: bigint): bigint;
    test(value: bigint, flag: bigint): boolean;
    subtract(value: bigint, flag: bigint): bigint;
};

export { api as API, APIAuthentication, APIAuthenticationType, APIClient, APIClientOptions, APIResponse, BROAD_PERMISSIONS_MAP, ByteString, ChannelType, ContainerState, DEFAULT_BASE_URL, Endpoint, Endpoints, ErroredAPIResponse, Hop, HopAPIError, IS_BROWSER, PROJECT_PERMISSION, PartialAPIOptions, Query, RuntimeType, SuccessfulAPIResponse, isValidByteString, parseSize, permissions, permissionsMap, roles, units, validateAPIAuthentication };
