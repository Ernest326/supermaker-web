declare type Method = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
declare type Empty = void;
declare type Tag<T, Name extends string> = T & {
    /**
     * Mark a type as having a specific name in the API
     * @internal
     */
    ___tag: Name;
};
/**
 * Hop's API uses ISO 8601 date strings
 */
declare type Timestamp = Tag<string, 'timestamp'>;
declare type ExtractRouteParams<T extends string> = string extends T ? Record<string, string | number | undefined> : T extends `${string}:${infer Param}/${infer Rest}` ? {
    [k in Param | keyof ExtractRouteParams<Rest>]: string | number;
} : T extends `${string}:${infer Param}` ? {
    [k in Param]: string | number;
} : {};
declare type Values<T> = T[keyof T];
declare const ID_PREFIXES: readonly [{
    readonly prefix: "user";
    readonly description: "Users";
}, {
    readonly prefix: "project";
    readonly description: "Project";
}, {
    readonly prefix: "pm";
    readonly description: "Project Members";
}, {
    readonly prefix: "role";
    readonly description: "Roles";
}, {
    readonly prefix: "pi";
    readonly description: "Project Invite";
}, {
    readonly prefix: "ptk";
    readonly description: "Project token";
}, {
    readonly prefix: "pat";
    readonly description: "User personal access token";
}, {
    readonly prefix: "container";
    readonly description: "Ignite container";
}, {
    readonly prefix: "pipe_room";
    readonly description: "Pipe room";
}, {
    readonly prefix: "deployment";
    readonly description: "Ignite deployment";
}, {
    readonly prefix: "bearer";
    readonly description: "Users bearer token";
}, {
    readonly prefix: "ptkid";
    readonly description: "Project token ID";
}, {
    readonly prefix: "secret";
    readonly description: "Project secret ID";
}, {
    readonly prefix: "gateway";
    readonly description: "Gateway";
}, {
    readonly prefix: "domain";
    readonly description: "Domain for a gateway";
}, {
    readonly prefix: "leap_token";
    readonly description: "Token for connecting to leap as a client";
}, {
    readonly prefix: "build";
    readonly description: "Build ID for build logs";
}];
declare type IdPrefixes = typeof ID_PREFIXES[number]['prefix'];
declare type Id<T extends IdPrefixes> = `${T}_${string}`;
declare type HopShDomain = `${string}.hop.sh`;
declare type InternalHopDomain = `${string}.hop`;
declare type AnyId = Id<IdPrefixes>;
declare function validateIdPrefix<T extends IdPrefixes = IdPrefixes>(prefix: string, expect?: T): prefix is T;
/**
 * Validates that a string is a valid ID
 *
 * @param maybeId A string that might be an id
 * @param prefix Optionally an id prefix to check against
 * @returns true if the string is an id
 */
declare function validateId<T extends IdPrefixes = IdPrefixes>(maybeId: string, prefix?: T): maybeId is Id<T>;
declare function getIdPrefix<T extends IdPrefixes>(id: string, expect?: T): T;
/**
 * Casts a variable into an ID for TypeScript
 *
 * @param id The variable to cast into an id
 * @param prefix The type of id to cast to
 * @returns A valid id string
 *
 * @example
 * ```ts
 * declare function createContainer(id: Id<'container'>): void
 * declare const containerId: string;
 *
 * // Error, string cannot be assigned to Id<'container'>
 * createContainer(containerId);
 *
 * // Successfully casts and compiles
 * createContainer(asId(containerId, 'container'));
 * ```
 */
declare function asId<T extends IdPrefixes>(id: string, prefix: T): `${T}_${string}`;
/**
 * Alias for {@link asId}
 */
declare const id: typeof asId;
declare function assertId<T extends IdPrefixes = IdPrefixes>(maybeId: string, prefix?: T, message?: string): asserts maybeId is Id<T>;

export { AnyId as A, Empty as E, HopShDomain as H, Id as I, Method as M, Timestamp as T, Values as V, InternalHopDomain as a, ExtractRouteParams as b, Tag as c, ID_PREFIXES as d, IdPrefixes as e, validateId as f, getIdPrefix as g, asId as h, id as i, assertId as j, validateIdPrefix as v };
