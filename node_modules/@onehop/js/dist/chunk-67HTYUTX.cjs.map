{"version":3,"sources":["../src/util/types.ts"],"names":["prefix","id"],"mappings":";;;;;;;;AA2BO,IAAM,cAAc;AAAA,EAC1B;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EAQA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AAAA,EACA;AAAA,IACC,QAAQ;AAAA,IACR,aAAa;AAAA,EACd;AACD;AAQO,SAAS,iBACf,QACA,QACc;AACd,MAAI,QAAQ;AACX,WAAO,WAAW;AAAA,EACnB;AAEA,SAAO,YAAY,KAAK,CAAC,EAAC,QAAQ,EAAC,MAAM,MAAM,MAAM;AACtD;AASO,SAAS,WACf,SACA,QACmB;AACnB,MAAI,CAAC,QAAQ;AACZ,WAAO,YAAY,KAAK,CAAC,EAAC,QAAAA,QAAM,MAAM,QAAQ,WAAW,GAAGA,UAAS,CAAC;AAAA,EACvE;AAEA,SAAO,QAAQ,WAAW,MAAM;AACjC;AAEO,SAAS,YAAkCC,KAAY,QAAY;AACzE,MAAI,UAAU,CAAC,WAAWA,KAAI,MAAM,GAAG;AACtC,UAAM,IAAI,MAAM,YAAYA,2BAA0B,QAAQ;AAAA,EAC/D;AAEA,QAAM,CAAC,MAAM,IAAIA,IAAG,MAAM,GAAG;AAE7B,MAAI,CAAC,UAAU,CAAC,iBAAiB,QAAQ,MAAM,GAAG;AACjD,UAAM,UAAU,SACb,YAAYA,wCAAuC,cACnD,YAAYA,wCAAuC;AAEtD,UAAM,IAAI,MAAM,OAAO;AAAA,EACxB;AAEA,SAAO;AACR;AAqBO,SAAS,KAA2BA,KAAY,QAAW;AACjE,SAAOA;AACR;AAKO,IAAM,KAAK;AAEX,SAAS,SACf,SACA,QACA,SAC2B;AAC3B,MAAI,CAAC,WAAW,SAAS,MAAM,GAAG;AACjC,UAAM,IAAI;AAAA,MACT,WAAW,eAAe,qBAAqB;AAAA,IAChD;AAAA,EACD;AACD","sourcesContent":["export type Method = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\nexport type Empty = void;\n\nexport type Tag<T, Name extends string> = T & {\n\t/**\n\t * Mark a type as having a specific name in the API\n\t * @internal\n\t */\n\t___tag: Name;\n};\n\n/**\n * Hop's API uses ISO 8601 date strings\n */\nexport type Timestamp = Tag<string, 'timestamp'>;\n\nexport type ExtractRouteParams<T extends string> = string extends T\n\t? Record<string, string | number | undefined>\n\t: T extends `${string}:${infer Param}/${infer Rest}`\n\t? {[k in Param | keyof ExtractRouteParams<Rest>]: string | number}\n\t: T extends `${string}:${infer Param}`\n\t? {[k in Param]: string | number}\n\t: {};\n\nexport type Values<T> = T[keyof T];\n\nexport const ID_PREFIXES = [\n\t{\n\t\tprefix: 'user',\n\t\tdescription: 'Users',\n\t},\n\t{\n\t\tprefix: 'project',\n\t\tdescription: 'Project',\n\t},\n\t{\n\t\tprefix: 'pm',\n\t\tdescription: 'Project Members',\n\t},\n\t{\n\t\tprefix: 'role',\n\t\tdescription: 'Roles',\n\t},\n\t{\n\t\tprefix: 'pi',\n\t\tdescription: 'Project Invite',\n\t},\n\t{\n\t\tprefix: 'ptk',\n\t\tdescription: 'Project token',\n\t},\n\t{\n\t\tprefix: 'pat',\n\t\tdescription: 'User personal access token',\n\t},\n\t{\n\t\tprefix: 'container',\n\t\tdescription: 'Ignite container',\n\t},\n\t{\n\t\tprefix: 'pipe_room',\n\t\tdescription: 'Pipe room',\n\t},\n\t{\n\t\tprefix: 'deployment',\n\t\tdescription: 'Ignite deployment',\n\t},\n\t{\n\t\tprefix: 'bearer',\n\t\tdescription: 'Users bearer token',\n\t},\n\t{\n\t\tprefix: 'ptkid',\n\t\tdescription: 'Project token ID',\n\t},\n\t// Technically, yes, it should be here, but channel IDs can also\n\t// be any random string if a developer decides to set it\n\t// themselves. So I'll leave it commented for now..\n\t// {\n\t// \tprefix: 'channel',\n\t// \tdescription: 'Channel',\n\t// },\n\t{\n\t\tprefix: 'secret',\n\t\tdescription: 'Project secret ID',\n\t},\n\t{\n\t\tprefix: 'gateway',\n\t\tdescription: 'Gateway',\n\t},\n\t{\n\t\tprefix: 'domain',\n\t\tdescription: 'Domain for a gateway',\n\t},\n\t{\n\t\tprefix: 'leap_token',\n\t\tdescription: 'Token for connecting to leap as a client',\n\t},\n\t{\n\t\tprefix: 'build',\n\t\tdescription: 'Build ID for build logs',\n\t},\n] as const;\n\nexport type IdPrefixes = typeof ID_PREFIXES[number]['prefix'];\nexport type Id<T extends IdPrefixes> = `${T}_${string}`;\nexport type HopShDomain = `${string}.hop.sh`;\nexport type InternalHopDomain = `${string}.hop`;\nexport type AnyId = Id<IdPrefixes>;\n\nexport function validateIdPrefix<T extends IdPrefixes = IdPrefixes>(\n\tprefix: string,\n\texpect?: T,\n): prefix is T {\n\tif (expect) {\n\t\treturn prefix === expect;\n\t}\n\n\treturn ID_PREFIXES.some(({prefix: p}) => p === prefix);\n}\n\n/**\n * Validates that a string is a valid ID\n *\n * @param maybeId A string that might be an id\n * @param prefix Optionally an id prefix to check against\n * @returns true if the string is an id\n */\nexport function validateId<T extends IdPrefixes = IdPrefixes>(\n\tmaybeId: string,\n\tprefix?: T,\n): maybeId is Id<T> {\n\tif (!prefix) {\n\t\treturn ID_PREFIXES.some(({prefix}) => maybeId.startsWith(`${prefix}_`));\n\t}\n\n\treturn maybeId.startsWith(prefix);\n}\n\nexport function getIdPrefix<T extends IdPrefixes>(id: string, expect?: T) {\n\tif (expect && !validateId(id, expect)) {\n\t\tthrow new Error(`Expected ${id} to be an id of type ${expect}`);\n\t}\n\n\tconst [prefix] = id.split('_');\n\n\tif (!prefix || !validateIdPrefix(prefix, expect)) {\n\t\tconst message = expect\n\t\t\t? `Expected ${id} to be a valid id with a prefix \\`${expect}\\`.`\n\t\t\t: `Expected ${id} to be a valid id. Found prefix \\`${prefix}\\`.`;\n\n\t\tthrow new Error(message);\n\t}\n\n\treturn prefix;\n}\n\n/**\n * Casts a variable into an ID for TypeScript\n *\n * @param id The variable to cast into an id\n * @param prefix The type of id to cast to\n * @returns A valid id string\n *\n * @example\n * ```ts\n * declare function createContainer(id: Id<'container'>): void\n * declare const containerId: string;\n *\n * // Error, string cannot be assigned to Id<'container'>\n * createContainer(containerId);\n *\n * // Successfully casts and compiles\n * createContainer(asId(containerId, 'container'));\n * ```\n */\nexport function asId<T extends IdPrefixes>(id: string, prefix: T) {\n\treturn id as Id<T>;\n}\n\n/**\n * Alias for {@link asId}\n */\nexport const id = asId;\n\nexport function assertId<T extends IdPrefixes = IdPrefixes>(\n\tmaybeId: string,\n\tprefix?: T,\n\tmessage?: string,\n): asserts maybeId is Id<T> {\n\tif (!validateId(maybeId, prefix)) {\n\t\tthrow new Error(\n\t\t\tmessage ?? `Invalid id: ${maybeId}. Expected ${prefix}_{string}`,\n\t\t);\n\t}\n}\n"]}