import { useState, useEffect, createContext, useContext, useMemo, useCallback } from 'react';
import { leap, hop, util, pipe, hls } from '@onehop/client';
import { LeapConnectionState } from '@onehop/leap-edge-js';
export { LeapConnectionState as ConnectionState } from '@onehop/leap-edge-js';

function useAtom(atom) {
  const [value, setValue] = useState({
    atom
  });
  useEffect(() => {
    const listening = atom.addListener(() => {
      setValue({
        atom
      });
    });
    return () => {
      listening.remove();
    };
  }, [atom]);
  return value.atom.get();
}

const leapContext = /*#__PURE__*/createContext(leap.instance);
function useLeap() {
  return useContext(leapContext);
}
function useConnect() {
  const leap = useLeap();
  return auth => {
    leap.connect(auth);
  };
}
function useConnectionState() {
  const client = useLeap();
  return useAtom(client.getConnectionState(true));
}
/**
 * Initialises Hop's client. This hook should only be rendered
 * at the top level of your app (e.g. so the component only mounts once).
 *
 * Extremely useful for things like Server Side Rendering, as it won't allow
 * hop to connect to leap until we're in the browser.
 *
 * If you want to initialise yourself feel free to copy the hook
 * into your own code. Or, if you're completely client side rendered
 * and don't have a React server rendering step, then you can call
 * hop.init outside of React lifecycle and all @onehop/react hooks will
 * still work exactly as expected.
 *
 * @param params Authentication parameters for leap
 */

function useInit(params) {
  useEffect(() => {
    if (typeof window === 'undefined') {
      return;
    }

    if (!params) {
      throw new Error('Leap authentication params are required when using useInit in the browser');
    }

    hop.init(params);
  }, []);
}

function useObservableMapGet(map, key) {
  const [storeState, setStoreState] = useState(() => key ? map.get(key) : undefined);
  useEffect(() => {
    const subscription = map.addListener((instance, payload) => {
      if ('key' in payload && payload.key === key) {
        setStoreState(map.get(key));
      } else if (payload.type === 'clear') {
        setStoreState(undefined);
      }
    });
    return () => {
      subscription.remove();
    };
  }, [key, map]);
  return storeState;
}
function useObserveObservableMap(map, listener) {
  useEffect(() => {
    const subscription = map.addListener(listener);
    return () => {
      subscription.remove();
    };
  }, [map]);
}

// from the client.
// export function useSendChannelMessage<T = any>(
// 	channel: string,
// 	eventName: string,
// ) {
// 	const client = useLeap();
// 	return (data: T) => {
// 		client.sendMessage(channel, eventName, data);
// 	};
// }

function useChannelMessage(channel, event, listener) {
  const client = useLeap();
  const connectionState = useConnectionState();
  const data = useObservableMapGet(client.getChannelStateMap(), channel);
  useEffect(() => {
    if (connectionState === LeapConnectionState.CONNECTED && (!data || data.subscription === 'non_existent')) {
      client.subscribeToChannel(channel);
    }
  }, [connectionState, data?.state]);
  useEffect(() => {
    const subscription = client.addMessageSubscription(channel, event, listener);
    return () => {
      subscription.remove();
    };
  }, []);
}
function useReadChannelState(channel) {
  const client = useLeap();
  const connectionState = useConnectionState();
  const data = useObservableMapGet(client.getChannelStateMap(), channel);
  useEffect(() => {
    if (connectionState === LeapConnectionState.CONNECTED && (!data || data.subscription === 'non_existent')) {
      client.subscribeToChannel(channel);
    }
  }, [connectionState, data?.subscription, data?.state]);

  if (!data) {
    const nonExistentData = {
      state: null,
      error: null,
      subscription: 'non_existent'
    };
    client.getChannelStateMap().set(channel, nonExistentData);
    return nonExistentData;
  }

  return data;
} // export function useSetChannelState<
// 	T extends API.Channels.State = API.Channels.State,
// >(channel: API.Channels.Channel['id']): Dispatch<SetStateAction<T>> {
// 	const client = useLeap();
// 	const oldState = useObservableMapGet(client.getChannelStateMap(), channel);
// 	return value => {
// 		if (!oldState) {
// 			return;
// 		}
// 		const newState = resolveSetStateAction<T>(oldState.state as T, value);
// 		client.setChannelState(channel, newState);
// 		client.getChannelStateMap().patch(channel, {
// 			state: newState,
// 		});
// 	};
// }
// Right now, we do not support setting channel state from the client
// export function useChannelState<
// 	T extends API.Channels.State = API.Channels.State,
// >(
// 	channel: API.Channels.Channel['id'],
// ): [data: leap.ChannelStateData<T>, setState: Dispatch<SetStateAction<T>>] {
// 	const state = useReadChannelState<T>(channel);
// 	const setState = useSetChannelState<T>(channel);
// 	return [state, setState];
// }

function useInterval(ms, fn) {
  useEffect(() => {
    const interval = setInterval(fn, ms);
    return () => {
      clearInterval(interval);
    };
  }, []);
}

const trackedPipeComponents = /*#__PURE__*/createContext(new util.maps.ObservableMap());
function useTrackPipeComponentCount(joinToken) {
  const map = useContext(trackedPipeComponents);
  const state = useObservableMapGet(map, joinToken ?? undefined);
  const leap = useLeap();
  useEffect(() => {
    if (!state && joinToken) {
      map.set(joinToken, util.atoms.create(0));
    }
  }, [state, joinToken]);
  useEffect(() => {
    if (!joinToken || !state) {
      return;
    }

    state.set(state.get() + 1);
    return () => {
      const value = state.get() - 1;

      if (value === 0) {
        leap.unsubscribeFromRoom(joinToken);
        map.delete(joinToken);
      } else {
        state.set(value);
      }
    };
  }, [joinToken, state]);
}
function usePipeRoom({
  ref,
  autojoin = true,
  joinToken
}) {
  const leap = useLeap();
  const connectionState = useConnectionState();
  const [controls, setControls] = useState(null);
  const [buffering, setBuffering] = useState(false);
  const [lastLatencyEmit] = useState(() => util.atoms.create(-1));
  const events = useMemo(() => util.emitter.create(), []);
  useInterval(500, () => {
    if (!controls?.hls) {
      return;
    }

    if (controls.hls.latency === lastLatencyEmit.get()) {
      return;
    }

    lastLatencyEmit.set(controls.hls.latency);
    events.emit('ESTIMATED_LATENCY', {
      latency: controls.hls.latency
    });
  });
  const roomStateMap = leap.getRoomStateMap();
  useObserveObservableMap(roomStateMap, useCallback(m => {
    if (!joinToken) {
      return;
    }

    const data = m.get(joinToken);

    if (!data || !data.room) {
      return;
    }

    events.emit('ROOM_UPDATE', data.room);
  }, [joinToken]));
  const stream = useObservableMapGet(roomStateMap, joinToken ?? undefined);
  useTrackPipeComponentCount(joinToken);
  useEffect(() => {
    if (connectionState !== LeapConnectionState.CONNECTED) {
      return;
    }

    if (!autojoin) {
      return;
    }

    if (autojoin && stream?.subscription === 'available') {
      return;
    }

    if (!joinToken) {
      return;
    }

    if (leap.getRoomStateMap().has(joinToken)) {
      return;
    }

    leap.subscribeToRoom(joinToken);
  }, [connectionState, autojoin, joinToken, stream?.subscription]);
  const canPlay = connectionState === LeapConnectionState.CONNECTED && ref.current !== null && stream?.subscription === 'available' && stream.connection.llhls?.edge_endpoint !== undefined;
  useEffect(() => {
    if (!canPlay) {
      return;
    }

    const controls = pipe.mount(ref.current, stream.connection.llhls.edge_endpoint);
    setControls(controls);

    const errorListener = (event, data) => {
      if (data.details !== hls.ErrorDetails.BUFFER_STALLED_ERROR) {
        return;
      }

      events.emit('BUFFERING', {
        buffering: true
      });
      setBuffering(true);
    };

    const fragBufferedListener = (event, data) => {
      events.emit('BUFFERING', {
        buffering: false
      });
      setBuffering(false);
    };

    if (controls.isNative) {
      // iOS Safari polyfills
      setBuffering(false);
    } else {
      controls.hls?.on(hls.Events.ERROR, errorListener);
      controls.hls?.on(hls.Events.FRAG_BUFFERED, fragBufferedListener);
    }

    return () => {
      controls.destroy();
      setControls(null);
      controls.hls?.off(hls.Events.ERROR, errorListener);
      controls.hls?.off(hls.Events.FRAG_BUFFERED, fragBufferedListener);
    };
  }, [canPlay, ref.current]);
  return {
    live: stream?.room?.state === 'live',
    canPlay,
    subscription: stream?.subscription ?? 'non_existent',
    events,
    buffering,
    controls,

    /**
     * Gets the estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced) returns 0 before first playlist is loaded
     */
    getLiveSync() {
      return controls?.hls?.liveSyncPosition ?? null;
    },

    /**
     * Gets the estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced) returns 0 before first playlist is loaded
     */
    getLatency() {
      return controls?.hls?.latency ?? null;
    },

    /**
     * Requests a subscription to the pipe room. You only need to use this if you don't use the autojoin feature.
     */
    join() {
      if (!joinToken) {
        throw new Error('Cannot join a room without a valid join token passed to `usePipeRoom`.');
      }

      leap.subscribeToRoom(joinToken);
    }

  };
}

export { trackedPipeComponents, useChannelMessage, useConnect, useConnectionState, useInit, useLeap, usePipeRoom, useReadChannelState, useTrackPipeComponentCount };
