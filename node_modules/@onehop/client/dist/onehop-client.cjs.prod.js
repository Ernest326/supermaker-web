'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var leapEdgeJs = require('@onehop/leap-edge-js');
var Hls = require('hls.js');

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n["default"] = e;
	return Object.freeze(n);
}

var Hls__namespace = /*#__PURE__*/_interopNamespace(Hls);

class HopEmitter {
  constructor() {
    this.listeners = new Map();
  }

  createListener(_key, fn) {
    return fn;
  }
  /**
   * Subscribe and listen to an event
   * @param key The event name to listen for
   * @param listener A listener for this event
   * @returns A function that can be called to unsubscribe the listener
   * @example
   * ```
   * const unsubscribe = client.on('MESSAGE', console.log);
   * // Unsubscribe later...
   * unsubscribe();
   * ```
   */


  on(key, listener) {
    const existing = this.listeners.get(key) ?? [];
    const merged = new Set([...existing, listener]);
    this.listeners.set(key, merged);
    return () => {
      const set = this.listeners.get(key);

      if (!set) {
        return;
      }

      if (set.size === 0) {
        this.listeners.delete(key);
      }

      set.delete(listener);
    };
  }
  /**
   * Subscribe and listen to an event once only
   * @param key The event name to listen for
   * @param listener A listener for this event
   * @returns A function that can be called to unsubscribe the listener before it even runs
   */


  once(key, listener) {
    const unsubscribe = this.on(key, data => {
      unsubscribe();
      return listener(data);
    });
    return unsubscribe;
  }
  /**
   * Remove a listener from an event
   * @param key The event name to remove a listener from
   * @param listener The listener to remove
   */


  off(key, listener) {
    const set = this.listeners.get(key);

    if (!set) {
      throw new Error("Cannot remove listener for key that doesn't exist.");
    }

    if (set.size === 0) {
      this.listeners.delete(key);
      return;
    }

    set.delete(listener);
  }
  /**
   * Emit an event to all listeners
   * @param key The event name to emit
   * @param data The data to emit
   */


  emit(key, data) {
    const listeners = this.listeners.get(key);

    if (!listeners) {
      return;
    } // In theory, shouldn't happen because we should have already checked
    // in the .off call


    if (listeners.size === 0) {
      this.listeners.delete(key);
      return;
    }

    for (const listener of listeners) {
      listener(data);
    }
  }

}

class HopEmitterInitialiser extends HopEmitter {
  static create = () => new HopEmitter();
}

const {
  create
} = HopEmitterInitialiser;

var emitter = /*#__PURE__*/Object.freeze({
	__proto__: null,
	HopEmitter: HopEmitter,
	create: create
});

/**
 * An atom, inspired much by Jotai, is a single bit of readible
 * state that can be observed and written to. It's useful for
 * React as we can easily update state when the atom changes
 * and use it as a shared global state store.
 *
 * @param initialValue An initial value to assign to the atom
 * @returns A readible and observable state object
 */
function atom(initialValue) {
  let atomValue = initialValue === undefined ? {
    uninitialized: true,
    value: undefined
  } : {
    value: initialValue
  };
  const listeners = new Set();

  const notify = () => {
    if ('uninitialized' in atomValue) {
      // In theory this would never happen
      // because the value would have
      // already been set and therefore
      // not unintialized
      return;
    }

    for (const listener of listeners) {
      listener(atomValue.value);
    }
  };

  return {
    get() {
      if ('uninitialized' in atomValue) {
        throw new Error('Cannot read the value of an atom that has no value yet.');
      }

      return atomValue.value;
    },

    set(value) {
      // Be efficient and don't update
      if (Object.is(atomValue.value, value)) {
        return;
      }

      atomValue = {
        value
      };
      notify();
    },

    addListener(listener) {
      listeners.add(listener);
      return {
        remove() {
          listeners.delete(listener);
        }

      };
    },

    removeListener(listener) {
      listeners.delete(listener);
    }

  };
}

var atoms = /*#__PURE__*/Object.freeze({
	__proto__: null,
	create: atom
});

class ObservableMap {
  map = new Map();
  listeners = new Set();

  get size() {
    return this.map.size;
  }

  get [Symbol.toStringTag]() {
    return 'ObservableMap';
  }

  clear() {
    this.map.clear();
    this.notify({
      type: 'clear'
    });
  }

  delete(key) {
    const success = this.map.delete(key);
    this.notify({
      type: 'delete',
      key
    });
    return success;
  }

  forEach(callbackfn, thisArg) {
    this.map.forEach(callbackfn, thisArg);
  }

  get(key) {
    return this.map.get(key);
  }

  has(key) {
    return this.map.has(key);
  }

  set(key, value) {
    this.map.set(key, value);
    this.notify({
      type: 'set',
      key,
      value
    });
    return this;
  }

  patch(key, value) {
    const old = this.map.get(key);

    if (old === undefined) {
      throw new Error('Cannot patch a value that does not already exist. Use `.set` instead.');
    }

    return this.set(key, { ...old,
      ...value
    });
  }
  /**
   * Merge with another map, with the new map overwriting members with the same key
   * @param map A map that has a matching set of keys and values
   */


  merge(map) {
    this.map = new Map([...this.map, ...map]);
    this.notify({
      type: 'merge'
    });
  }

  entries() {
    return this.map.entries();
  }

  keys() {
    return this.map.keys();
  }

  values() {
    return this.map.values();
  }

  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }

  addListener(listener) {
    this.listeners.add(listener);
    return {
      remove: () => {
        this.listeners.delete(listener);
      }
    };
  }

  removeListener(listener) {
    this.listeners.delete(listener);
  }

  notify(payload) {
    for (const listener of this.listeners) {
      listener(this, payload);
    }
  }

}

var maps = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ObservableMap: ObservableMap
});

const getMessageListenerKey = (channel, event) => `${channel}:${event}`;

var channels = /*#__PURE__*/Object.freeze({
	__proto__: null,
	getMessageListenerKey: getMessageListenerKey
});

var index$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	maps: maps,
	atoms: atoms,
	emitter: emitter,
	channels: channels
});

function createLeapEvent(config) {
  return {
    async handle(client, event) {
      const requireId = config.requireId !== false;

      if (!event.channelId && requireId) {
        throw new Error(`Received opcode for ${event.eventType} but expected an ID that was not there.`);
      }

      await config.handle(client, event.channelId, event.data);
    }

  };
}

const AVAILABLE = createLeapEvent({
  async handle(client, channelId, data) {
    client.getChannelStateMap().set(channelId, {
      error: null,
      state: data.channel.state,
      subscription: 'available'
    });
  }

});

const INIT = createLeapEvent({
  requireId: false,

  async handle(client, channelId, data) {
    const localState = new Map();

    for (const channel of data.channels) {
      localState.set(channel.id, {
        state: channel.state,
        subscription: 'available',
        error: null
      });
    }

    client.getChannelStateMap().merge(localState);
  }

});

const MESSAGE = createLeapEvent({
  async handle(client, channel, data) {
    const {
      e: event,
      d: messageData
    } = data;
    client.emit('MESSAGE', {
      event,
      data: messageData,
      channel
    });
    const key = getMessageListenerKey(channel, event);
    const listeners = client.getChannelMessageListeners().get(key);

    if (!listeners) {
      return;
    }

    if (listeners.size === 0) {
      client.getChannelMessageListeners().delete(key);
      return;
    }

    for (const listener of listeners) {
      listener(messageData);
    }
  }

});

const PIPE_ROOM_AVAILABLE = createLeapEvent({
  requireId: false,

  async handle(client, _, data) {
    client.getRoomStateMap().set(data.pipe_room.join_token, {
      subscription: 'available',
      room: data.pipe_room,
      connection: data.connection
    });
  }

});

const PIPE_ROOM_UNAVAILABLE = createLeapEvent({
  requireId: false,

  async handle(client, _, data) {
    client.getRoomStateMap().set(data.join_token, {
      subscription: 'unavailable',
      error: data,
      room: null
    });
  }

});

const PIPE_ROOM_UPDATE = PIPE_ROOM_AVAILABLE;

const STATE_UPDATE = createLeapEvent({
  async handle(client, channel, data) {
    client.getChannelStateMap().patch(channel, {
      state: data.state
    });
  }

});

const TOKEN_STATE_UPDATE = createLeapEvent({
  async handle(client, channelId, data) {
    client.getChannelStateMap().patch(channelId, {
      state: data.state
    });
  }

});

const UNAVAILABLE = createLeapEvent({
  async handle(client, channel, data) {
    client.getChannelStateMap().set(channel, {
      state: null,
      subscription: 'unavailable',
      error: data
    });
  }

});

const DIRECT_MESSAGE = createLeapEvent({
  requireId: false,

  async handle(client, channel, data) {
    const {
      e: event,
      d: messageData
    } = data;
    client.emit('MESSAGE', {
      event,
      data: messageData,
      channel: null
    });
    const listeners = client.getDirectMessageListeners().get(event);

    if (!listeners) {
      return;
    }

    if (listeners.size === 0) {
      client.getDirectMessageListeners().delete(event);
      return;
    }

    for (const listener of listeners) {
      listener(messageData);
    }
  }

});

class Client extends HopEmitter {
  static SUPPORTED_EVENTS = {
    INIT,
    AVAILABLE,
    UNAVAILABLE,
    STATE_UPDATE,
    TOKEN_STATE_UPDATE,
    MESSAGE,
    DIRECT_MESSAGE,
    PIPE_ROOM_UNAVAILABLE,
    PIPE_ROOM_AVAILABLE,
    PIPE_ROOM_UPDATE
  };
  hasPreviouslyConnected = false;
  connectionState = atom(leapEdgeJs.LeapConnectionState.IDLE);
  leap = null;
  channelStateMap = new ObservableMap();
  channelMessageListeners = new Map();
  directMessageListeners = new Map();
  roomStateMap = new ObservableMap();
  rawServiceEventListeners = new Set(); // Rule is broken — constructor is not useless because HopEmitter#constructor is protected
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor

  constructor() {
    super();
  }

  connect(auth, opts) {
    if (this.leap) {
      return;
    }

    const leap = this.getLeap(auth, opts);

    const serviceEvent = async message => {
      this.emit('SERVICE_EVENT', message);
      await this.handleServiceEvent(message);
    };

    const connectionStateUpdate = async state => {
      this.emit('CONNECTION_STATE_UPDATE', state);
      await this.handleConnectionStateUpdate(state);
    };

    leap.on('serviceEvent', serviceEvent);
    leap.on('connectionStateUpdate', connectionStateUpdate);
  }

  subscribeToRoom(joinToken) {
    const existingSubscription = this.roomStateMap.get(joinToken);
    const payload = {
      e: 'PIPE_ROOM_SUBSCRIBE',
      c: null,
      d: {
        join_token: joinToken
      }
    };

    if (existingSubscription) {
      if (existingSubscription.subscription === 'unavailable') {
        this.send(payload);
      }

      return;
    }

    this.send(payload);
    this.roomStateMap.set(joinToken, {
      subscription: 'pending',
      room: null
    });
  }

  unsubscribeFromRoom(joinToken) {
    const stream = this.roomStateMap.get(joinToken);

    if (!stream) {
      throw new Error('Not subscribed to that room!');
    } // This condition is annoying, because we don't know the room ID
    // as we never received 'AVAILABLE'
    // but we still want to make sure its no longer in this.roomStateMap
    // and that the server isn't still processing our subscription
    // Context: An app where there are multiple streams of something
    // 1) User enters stream and subscribes (we don't receive PIPE_ROOM_AVAILABLE yet)
    // 2) User realises they pressed wrong stream and quickly hits back
    // 3) We never got the available message, so we never got the room id
    // 4) How unsibcsribe
    // This is a bit of a hack, but it works


    if (stream.subscription !== 'available') {
      const listener = message => {
        if (message.eventType !== 'PIPE_ROOM_AVAILABLE') {
          return;
        }

        this.unsubscribeFromRoom(joinToken);
        this.rawServiceEventListeners.delete(listener);
      };

      this.rawServiceEventListeners.add(listener);
      return;
    }

    this.roomStateMap.delete(joinToken);
    this.send({
      e: 'PIPE_ROOM_UNSUBSCRIBE',
      d: {
        id: stream.room.id
      },
      c: null
    });
  }

  addMessageSubscription(channel, eventName, listener) {
    const map = this.getChannelMessageListeners();
    const key = getMessageListenerKey(channel, eventName);
    const listeners = map.get(key) ?? new Set();
    const castListener = listener;
    map.set(key, listeners.add(castListener));
    return {
      remove() {
        const currentListeners = map.get(key);

        if (!currentListeners) {
          return;
        }

        currentListeners.delete(castListener);

        if (currentListeners.size === 0) {
          map.delete(key);
        }
      }

    };
  }
  /**
   * Get a list of all subscriptions
   * @returns A list of all channel and room names we are currently subscribed to
   */


  getCurrentAvailableSubscriptions() {
    const filter = value => [...value.entries()].filter(([, entry]) => entry.subscription === 'available').map(entry => entry[0]);

    return {
      channels: filter(this.getChannelStateMap()),
      rooms: filter(this.getRoomStateMap())
    };
  }

  getChannelStateMap() {
    return this.channelStateMap;
  }

  getRoomStateMap() {
    return this.roomStateMap;
  }

  getChannelMessageListeners() {
    return this.channelMessageListeners;
  }

  getDirectMessageListeners() {
    return this.directMessageListeners;
  }

  getConnectionState(fullAtom = false) {
    if (fullAtom) {
      return this.connectionState;
    }

    return this.connectionState.get();
  }

  subscribeToChannel(channel) {
    const s = this.channelStateMap.get(channel)?.subscription;

    if (s && s === 'available') {
      return;
    }

    const state = {
      subscription: 'pending',
      state: null,
      error: null
    };
    this.channelStateMap.set(channel, state);
    this.send({
      e: 'SUBSCRIBE',
      d: null,
      c: channel
    });
    return state;
  }

  unsubscribeFromChannel(channel) {
    this.channelStateMap.delete(channel);
    this.send({
      e: 'UNSUBSCRIBE',
      d: null,
      c: channel
    });
  }

  setChannelState(channel, state) {
    this.send({
      e: 'SET_CHANNEL_STATE',
      c: channel,
      d: state
    });
  }

  sendMessage(channel, event, payload) {
    this.send({
      e: 'MESSAGE',
      c: channel,
      d: {
        e: event,
        d: payload
      }
    });
  }

  async handleConnectionStateUpdate(state) {
    if (state === leapEdgeJs.LeapConnectionState.ERRORED && this.hasPreviouslyConnected) {
      const l = this.connectionState.addListener(state => {
        if (state !== leapEdgeJs.LeapConnectionState.CONNECTED) {
          return;
        } // If we have a leap token, subscriptions are persisted
        // on the server. There's no need to resubscribe.


        if (!this.getLeap().auth.token) {
          this.resubscribe();
        }

        l.remove();
      });
    }

    if (!this.hasPreviouslyConnected) {
      this.hasPreviouslyConnected = true;
    }

    this.connectionState.set(state);
  }

  resubscribe() {
    const {
      channels,
      rooms
    } = this.getCurrentAvailableSubscriptions();
    console.log('resubscribing to', {
      channels,
      rooms
    });

    for (const channel of channels) {
      this.subscribeToChannel(channel);
    }

    for (const room of rooms) {
      this.subscribeToRoom(room);
    }
  }

  async handleServiceEvent(event) {
    const handler = Client.SUPPORTED_EVENTS[event.eventType];

    if (!handler) {
      console.warn('[@onehop/client] Channels: Received unsupported opcode!', event);
      return;
    }

    try {
      await handler.handle(this, event);
    } catch (error) {
      console.warn('[@onehop/client] Handling service message failed');
      console.warn(error);
    }
  }

  send(data) {
    this.getLeap().sendServicePayload(data);
  }

  getLeap(auth, opts) {
    if (this.leap) {
      if (auth) {
        this.leap.auth = auth;
      }

      return this.leap;
    }

    if (!auth) {
      throw new Error('Cannot create a new Leap instance as no authentication params were provided');
    }

    this.leap = new leapEdgeJs.LeapEdgeClient(auth, opts);
    this.leap.connect();
    return this.leap;
  }

}
const instance = new Client();

var index$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Client: Client,
	instance: instance
});

const APPLE_HLS_MIME = 'application/vnd.apple.mpegurl';
const LIVE_LLHLS_SYNC_BCE = 3;
const WCL_DELAY_LES = 5;
const defaultConfig = {
  lowLatencyMode: true,
  backBufferLength: 10,
  autoStartLoad: true,
  enableWorker: true,
  abrBandWidthFactor: 1,
  liveSyncDuration: LIVE_LLHLS_SYNC_BCE
};
class Controls {
  constructor(node, hls) {
    this.node = node;
    this._hls = hls;
  }
  /**
   * Syncs to live edge
   *
   * @param distance The seconds to sync from live edge (e.g. a buffer)
   */


  sync(distance = LIVE_LLHLS_SYNC_BCE) {
    this.node.currentTime = this.node.duration - distance;
  }

  async stop() {
    this.node.pause();
  }

  async play() {
    await this.node.play();
    this.sync(3.5);
  }

  get isPaused() {
    return this.node.paused;
  }

  destroy() {
    this.hls.destroy();
  }

  get isNative() {
    return !this._hls;
  }

  get hls() {
    if (!this._hls) {
      throw new Error('Cannot get HLS instance as video is being streamed natively.');
    }

    return this._hls;
  }

}
function mount(node, url, hlsConfigOverride) {
  let instance;

  if (Hls__namespace["default"].isSupported()) {
    instance = new Hls__namespace["default"]({ ...defaultConfig,
      ...hlsConfigOverride
    });
  } else if (node.canPlayType(APPLE_HLS_MIME)) {
    node.src = url;
    return new Controls(node);
  } else {
    throw new Error('HLS Will not work in this browser', {
      cause: new Error('This browser does not support HLS or MSE: https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API')
    });
  }

  const syncToBCE = () => {
    if (node.duration < LIVE_LLHLS_SYNC_BCE) {
      return;
    }

    node.currentTime = node.duration - LIVE_LLHLS_SYNC_BCE;
  };

  node.onplay = () => {
    syncToBCE();
  };

  const liveSync = setInterval(() => {
    if (node && !node.paused && instance.latency > LIVE_LLHLS_SYNC_BCE + WCL_DELAY_LES) {
      syncToBCE();
    }
  }, 1000);
  instance.on(Hls__namespace["default"].Events.MEDIA_DETACHING, () => {
    clearInterval(liveSync);
  });
  instance.loadSource(url);
  instance.attachMedia(node);
  return new Controls(node, instance);
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	APPLE_HLS_MIME: APPLE_HLS_MIME,
	LIVE_LLHLS_SYNC_BCE: LIVE_LLHLS_SYNC_BCE,
	WCL_DELAY_LES: WCL_DELAY_LES,
	Controls: Controls,
	mount: mount
});

function init(leapConnectionParams, options) {
  instance.connect(leapConnectionParams, options?.leapSocketUrl ? {
    socketUrl: options.leapSocketUrl,
    debug: false
  } : undefined);
  return instance;
}

var hop = /*#__PURE__*/Object.freeze({
	__proto__: null,
	init: init
});

exports.hls = Hls__namespace;
exports.hop = hop;
exports.leap = index$1;
exports.pipe = index;
exports.util = index$2;
